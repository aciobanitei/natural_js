<article class="refr050203 apiDoc">
	<h2>
		<span lang="ko_KR">기본옵션</span>
		<span lang="en_US">Default Options</span>
	</h2>
	<table class="api form">
		<tr>
			<th>Name</th>
			<th>Type</th>
			<th>Default</th>
			<th>Required</th>
			<th style="width: auto;">Description</th>
		</tr>
		<tr>
			<td>context</td>
			<td>jquery object|jquery selector string</td>
			<td>null</td>
			<td style="text-align: center;">O</td>
			<td>Documents컴포넌트화 할 Documents 요소를 지정합니다.</td>
		</tr>
		<tr>
			<td>multi</td>
			<td>boolean</td>
			<td>true</td>
			<td style="text-align: center;">X</td>
			<td>
				<p>MDI, SDI 여부</p>
				<p>true 이면 MDI 타입으로 탭 링크들과 컨텐츠들을 표시하고 false 이면 컨텐츠 탭 링크는 표시 하지 않고 단 한 개의 컨텐츠만 표시 합니다.</p>
			</td>
		</tr>
		<tr>
			<td>maxStateful</td>
			<td>number</td>
			<td>0</td>
			<td style="text-align: center;">X</td>
			<td>
				<p lang="ko_KR">multi 옵션이 true 인 경우 추가 탭 컨텐츠를 열 때마다 웹 브라우저가 느려지지 않도록 최대 상태 유지 탭 컨텐츠 수를 설정할 수 있습니다.</p>
				<p lang="en_US">If the multi option is true, the maximum number of stateful tab contents can be set to prevent the web browser from slowing down whenever additional tab contents are opened.</p>
				<p lang="ko_KR" class="alert">새로운 컨텐츠를 열때 열려있는 탭 컨텐츠의 개수가 최대 상태유지 개수를 초과 하면 제일 먼저 열린 탭 컨텐츠의 상태가 제거되고 상태유지가 제거 된 탭을 클릭 하면 해당 컨텐츠가 다시 로딩 됩니다.</p>
				<p lang="en_US" class="alert">When opening the new content, if the number of open tab contents exceeds the maximum stateful count, the state of the first opened tab content is removed, and  clicking on the tab with the removed state, it will reload the content.</p>
				<p lang="ko_KR" class="alert">값이 0 이면 최대 상태유지 컨텐츠 수를 제한 하지 않습니다.</p>
                <p lang="en_US" class="alert">A value of 0 does not limit the maximum number of stateful content.</p>
			</td>
		</tr>
		<tr>
			<td>maxTabs</td>
			<td>number</td>
			<td>0</td>
			<td style="text-align: center;">X</td>
			<td>
				<p lang="ko_KR">multi 옵션이 true 인 경우 추가 탭 컨텐츠를 열 때마다 웹 브라우저가 느려지지 않도록 최대 탭 컨텐츠 수를 설정할 수 있습니다.</p>
				<p lang="en_US">If the multi option is true, the maximum number of tab contents can be set to prevent the web browser from slowing down whenever additional tab contents are opened.</p>
				<p lang="ko_KR" class="alert">새로운 컨텐츠를 열때 열려있는 탭 컨텐츠의 개수가 최대 탭 개수를 초과 하면 더이상 탭 컨텐츠를 열 수 없습니다. 새로운 컨텐츠를 열려면 기존 탭 중에 하나를 닫아야 합니다.</p>
				<p lang="en_US" class="alert">When opening new content, if the number of open tab contents exceeds the maximum tabs count, the tab contents can no longer be opened. To open new content, you must close one of the existing tabs.</p>
			    <p lang="ko_KR" class="alert">값이 0 이면 최대 컨텐츠 수를 제한 하지 않습니다.</p>
                <p lang="en_US" class="alert">If the value is 0, the maximum number of contents is not limited.</p>
			</td>
		</tr>
		<tr>
			<td>addLast</td>
			<td>boolean</td>
			<td>false</td>
			<td style="text-align: center;">X</td>
			<td>
				<p>true로 설정 하면 add 메서드를 호출 했을 때 새로운 탭이 마지막에 추가 됩니다.</p>
			</td>
		</tr>
		<tr>
			<td>tabScroll</td>
			<td>boolean</td>
			<td>false</td>
			<td style="text-align: center;">X</td>
			<td>
				<p>true로 설정 하면 탭들을 마우스 드래그나 터치로 스크롤 할 수 있습니다.</p>
			</td>
		</tr>
        <tr>
            <td>tabScrollCorrection</td>
            <td>boolean</td>
            <td>false</td>
            <td style="text-align: center;">X</td>
            <td>
                <p lang="ko_KR">탭 요소에 영향을 주는 스타일(CSS)에 의해 마지막 탭이 잘리거나 여백이 생길 수 있습니다. 이때 tabScrollCorrection 객체의 속성으로 다음 옵션 값들을 조절하여 정상적으로 표시되게 할 수 있습니다.</p>
                <p lang="en_US">The style (CSS) affecting the tab element may cause the last tab to be truncated or margins. At this time, you can adjust the following option values ​​as properties of the tabScrollCorrection object to display normally.</p>
                <ul>
                    <li lang="ko_KR">rightCorrectionPx : 마지막 탭이 잘리거나 여백이 생길때 1씩 증감하여 보정 합니다.</li>
                    <li lang="en_US">rightCorrectionPx : 마지막 탭이 잘리거나 여백이 생길때 1씩 증감하여 보정 합니다.</li>
                </ul>
                <pre><code class="language-javascript">N("#docs").docs({
    tabScrollCorrection : {
        rightCorrectionPx : 1
    }
});</code></pre>
                <p class="alert">natural.config.js 의 N.context.attr("ui.shell").docs 에 tabScrollCorrection 옵션을 적용하면 전체 N.docs 컴포넌트에 적용 됩니다.</p>
            </td>
        </tr>
		<tr>
			<td>closeAllRedirectURL</td>
			<td>string</td>
			<td>null</td>
			<td style="text-align: center;">X</td>
			<td>
				<p lang="ko_KR">"전체 닫기" 버튼을 클릭 했을 경우 closeAllRedirectURL 옵션 값이 null 이면 활성 화 된 탭을 제외한 나머지 탭들을 닫아고 url 문자열을 입력 하면 해당 url 로 리다이렉트 됩니다.</p>
				<p lang="en_US">When the "Close All" button is clicked, if the value of the closeAllRedirectURL option is null, all other tabs except the active tab are closed and if you input the url string, it  will be redirect to the url.</p>
				<p lang="ko_KR" class="alert">SPA(Single Page Application) 로  개발 할 때  홈(메인 인덱스)으로 이동하는 url 을 입력 하여 탭 전체가 닫힐때 만 이라도 페이지 리다이렉션이 일어나서 브라우저의 가비지 리소스들이 정리 되게 하는것을 권장 합니다.</p>
				<p lang="en_US" class="alert">When developing with SPA(Single Page Application), it is recommended to enter the url to go to the home(Main index page) so that even when the entire tab is closed, page redirection occurs, so that the garbage resources of the browser are cleaned.</p>
			</td>
		</tr>
		<tr>
			<td>entireLoadIndicator</td>
			<td>boolean</td>
			<td>false</td>
			<td style="text-align: center;">X</td>
			<td>
				<p>true로 설정 하면 페이지가 로딩 될 때 서버로 요청하는 Ajax 요청들이 모두 완료 될때 까지의 진행 상태 바를 보여 줍니다.</p>
			</td>
		</tr>
		<tr>
			<td>entireLoadScreenBlock</td>
			<td>boolean</td>
			<td>false</td>
			<td style="text-align: center;">X</td>
			<td>
				<p>true로 설정 하면 페이지가 로딩 될 때 서버로 요청하는 Ajax 요청들이 모두 완료 될때 까지 화면을 차단하여 Double Submit 을 방지 합니다.</p>
			</td>
		</tr>
		<tr>
			<td>entireLoadExcludeURLs</td>
			<td>array</td>
			<td>[]</td>
			<td style="text-align: center;">X</td>
			<td>
				<p>entireLoad 관련 이벤트나 옵션에서 캡쳐 되는 요청 중 entireLoadExcludeURLs 로 지정 한 URL 들은 캡쳐에서 제외 합니다.</p>
				<p class="alert">페이지가 처음 로딩 될 때 탭 컨텐츠 바깥에서 로딩되는 Ajax 호출을 제외하고 싶을 때 설정 바랍니다.</p>
				<p class="alert">등록 된 URL 들은 entireLoadIndicator 옵션과 entireLoadScreenBlock 옵션에도 연동 되어 표시 됩니다.</p>
			</td>
		</tr>
		<tr>
			<td>alwaysOnTop</td>
			<td>boolean</td>
			<td>false</td>
			<td style="text-align: center;">X</td>
			<td>
			    <p lang="ko_KR">true로 설정하면 메뉴목록 대화상자를 항상 최 상위에 표시 합니다.</p>
                <p lang="en_US">If set to true, The menu list dialog is always displayed at the top.</p>
			</td>
		</tr>
		<tr>
			<td>alwaysOnTopCalcTarget</td>
			<td>string</td>
			<td>"div, span, ul, p, nav, article, section"</td>
			<td style="text-align: center;">X</td>
			<td>
				alwaysOnTop 옵션 적용 시 최 상위 z-index를 계산하기 위한 대상 요소지정
				<p class="alert">jQuery selector 문자열로 지정 합니다</p>
			</td>
		</tr>
		<tr>
			<td>onBeforeLoad</td>
			<td>function</td>
			<td>null</td>
			<td style="text-align: center;">X</td>
			<td>
				<p>컨텐츠가 로딩 되기 전 실행 되는 이벤트 입니다.</p>
				<pre><code class="language-javascript">onBeforeLoad : function(docId, target) {
	// docId : Document Id
	// target : 컨텐츠가 로딩 될 요소

	// get document info
	var doc = this.doc(docId);
}</code></pre>
				<p class="alert">해당 컨텐츠가 닫히기 전 까지 다시 호출 되지 않습니다.</p>
				<p class="alert">컨텐츠가 로딩되기 전에 실행 되므로 cont 메서드로 컨텐츠의 Controller 를 가져 올 수 없습니다.</p>
			</td>
		</tr>
		<tr>
			<td>onLoad</td>
			<td>function</td>
			<td>null</td>
			<td style="text-align: center;">X</td>
			<td>
				<p>컨텐츠가 로딩 된 후 실행 되는 이벤트 입니다.</p>
				<pre><code class="language-javascript">onLoad : function(docId) {
	// docId : Document Id

	// get document info
	var doc = this.doc(docId);
	// get document's Controller
	var docCont = this.cont(docId);
	var docView = this.cont(docId).view;
	var docRequest = this.cont(docId).request;
}</code></pre>
				<p class="alert">해당 컨텐츠가 닫히기 전 까지 다시 호출 되지 않습니다.</p>
			</td>
		</tr>
		<tr>
			<td>onBeforeEntireLoad</td>
			<td>function</td>
			<td>null</td>
			<td style="text-align: center;">X</td>
			<td>
				<p>컨텐츠 로딩 시 동시에 실행 되는 여러 서버 요청(N.comm.submit)들 중 최초 요청이 실행 되기 전 실행되는 이벤트</p>
				<pre><code class="language-javascript">onBeforeEntireLoad : function(docId) {
	// docId : Document Id

	// get document info
	var doc = this.doc(docId);
}</code></pre>
				<p class="alert">컨텐츠 로딩 전 최초 한번은 컨텐츠가 로딩되기 전에 이벤트가 실행 되므로 cont 메서드로 컨텐츠의 Controller 를 가져 올 수 없습니다.</p>
			</td>
		</tr>
		<tr>
			<td>onErrorEntireLoad</td>
			<td>function</td>
			<td>null</td>
			<td style="text-align: center;">X</td>
			<td>
				<p>컨텐츠 로딩 시 동시에 실행 되는 여러 서버 요청(N.comm.submit)들 중 에러가 발생 했을때 실행되는 이벤트</p>
				<pre><code class="language-javascript">onErrorEntireLoad : function(e, request, xhr, textStatus, callback) {
	// e(arguments[0]) : ErrorThrown
    // request(arguments[1]) : Communicator.request
    // xhr(arguments[2]) : jQuery XMLHTTORequest
    // textStatus(arguments[3]) : "success"(submit 콜백에서 에러 발생 시) 또는 "error"(서버에서 오류 발생 시)
    // callback(arguments[4]) : textStatus 값이 "success" 일때 submit 메서드의 인자로 지정한 콜백 함수
}</code></pre>
                <p class="alert">onErrorEntireLoad의 이벤트 핸들러 함수는 N.comm.error 메서드의 callback 과 같습니다.</p>
			</td>
		</tr>
		<tr>
			<td>onEntireLoad</td>
			<td>function</td>
			<td>null</td>
			<td style="text-align: center;">X</td>
			<td>
				<p>컨텐츠 로딩 시 동시에 실행 되는 여러 서버 요청(N.comm.submit)들이 모두 완료 되었을 때 실행되는 이벤트</p>
				<pre><code class="language-javascript">onEntireLoad : function(docId) {
	// docId : Document Id

	// get document info
	var doc = this.doc(docId);
	// get document's Controller
	var docCont = this.cont(docId);
	var docView = this.cont(docId).view;
	var docRequest = this.cont(docId).request;
}</code></pre>
			</td>
		</tr>
		<tr>
			<td>onBeforeActive</td>
			<td>function</td>
			<td>null</td>
			<td style="text-align: center;">X</td>
			<td>
				<p>선택한 탭이 활성화 되기 전 마다 실행 되는 이벤트</p>
				<pre><code class="language-javascript">onBeforeActive : function(docId) {
	// docId : Document Id

	// get document info
	var doc = this.doc(docId);
	// get document's Controller
	var docCont = this.cont(docId);
	var docView = this.cont(docId).view;
	var docRequest = this.cont(docId).request;
}</code></pre>
			</td>
		</tr>
		<tr>
			<td>onActive</td>
			<td>function</td>
			<td>null</td>
			<td style="text-align: center;">X</td>
			<td>
				<p>선택한 탭이 활성화 될 때 마다 실행 되는 이벤트</p>
				<pre><code class="language-javascript">onActive : function(docId) {
	// docId : Document Id

	// get document info
	var doc = this.doc(docId);
	// get document's Controller
	var docCont = this.cont(docId);
	var docView = this.cont(docId).view;
	var docRequest = this.cont(docId).request;
}</code></pre>
			</td>
		</tr>
		<tr>
			<td>onBeforeInactive</td>
			<td>function</td>
			<td>null</td>
			<td style="text-align: center;">X</td>
			<td>
				<p>선택한 탭이 비활성화 되기 전 마다 실행 되는 이벤트</p>
				<pre><code class="language-javascript">onBeforeInactive : function(docId) {
	// docId : Document Id

	// get document info
	var doc = this.doc(docId);
	// get document's Controller
	var docCont = this.cont(docId);
	var docView = this.cont(docId).view;
	var docRequest = this.cont(docId).request;
}</code></pre>
			</td>
		</tr>
		<tr>
			<td>onInactive</td>
			<td>function</td>
			<td>null</td>
			<td style="text-align: center;">X</td>
			<td>
				<p>선택한 탭이 비활성화 될 때 마다 실행 되는 이벤트</p>
				<pre><code class="language-javascript">onInactive : function(docId) {
	// docId : Document Id

	// get document info
	var doc = this.doc(docId);
	// get document's Controller
	var docCont = this.cont(docId);
	var docView = this.cont(docId).view;
	var docRequest = this.cont(docId).request;
}</code></pre>
			</td>
		</tr>
		<tr>
			<td>onBeforeRemoveState</td>
			<td>function</td>
			<td>null</td>
			<td style="text-align: center;">X</td>
			<td>
				<p>선택한 탭의 상태가 제거 되기 전 마다 실행 되는 이벤트</p>
				<pre><code class="language-javascript">onBeforeRemoveState : function(docId) {
	// docId : Document Id

	// get document info
	var doc = this.doc(docId);
	// get document's Controller
	var docCont = this.cont(docId);
	var docView = this.cont(docId).view;
	var docRequest = this.cont(docId).request;
}</code></pre>
			</td>
		</tr>
		<tr>
			<td>onRemoveState</td>
			<td>function</td>
			<td>null</td>
			<td style="text-align: center;">X</td>
			<td>
				<p>선택한 탭의 상태가 제거 될 때 마다 실행 되는 이벤트</p>
				<pre><code class="language-javascript">onRemoveState : function(docId) {
	// docId : Document Id

	// get document info
	var doc = this.doc(docId);
	// get document's Controller
	var docCont = this.cont(docId);
	var docView = this.cont(docId).view;
	var docRequest = this.cont(docId).request;
}</code></pre>
			</td>
		</tr>
		<tr>
			<td>onBeforeRemove</td>
			<td>function</td>
			<td>null</td>
			<td style="text-align: center;">X</td>
			<td>
				<p>선택한 탭이 제거 되기 전 마다 실행 되는 이벤트</p>
				<pre><code class="language-javascript">onBeforeRemove : function(docId) {
	// docId : Document Id

	// get document info
	var doc = this.doc(docId);
	// get document's Controller
	var docCont = this.cont(docId);
	var docView = this.cont(docId).view;
	var docRequest = this.cont(docId).request;
}</code></pre>
			</td>
		</tr>
		<tr>
			<td>onRemove</td>
			<td>function</td>
			<td>null</td>
			<td style="text-align: center;">X</td>
			<td>
				<p>선택한 탭이 제거 될 때 마다 실행 되는 이벤트</p>
				<pre><code class="language-javascript">onRemove : function(docId) {
	// docId : Document Id

	// get document info
	var doc = this.doc(docId);
	// get document's Controller
	var docCont = this.cont(docId);
	var docView = this.cont(docId).view;
	var docRequest = this.cont(docId).request;
}</code></pre>
			</td>
		</tr>
	</table>
</article>

<script type="text/javascript">
N(".refr050203").cont({
    init : function(view, request) {

    }
});
</script>